<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>elbowH的博客</title>
    <meta name="generator" content="VuePress 1.9.9">
    
    <meta name="description" content="记录学习过程">
    
    <link rel="preload" href="/mynotes/assets/css/0.styles.1c00a5d2.css" as="style"><link rel="preload" href="/mynotes/assets/js/app.f65f9fb1.js" as="script"><link rel="preload" href="/mynotes/assets/js/2.7a2c11e9.js" as="script"><link rel="preload" href="/mynotes/assets/js/4.6de9dd4b.js" as="script"><link rel="prefetch" href="/mynotes/assets/js/10.7ac305b1.js"><link rel="prefetch" href="/mynotes/assets/js/11.36532f04.js"><link rel="prefetch" href="/mynotes/assets/js/12.75928cce.js"><link rel="prefetch" href="/mynotes/assets/js/13.50300c4e.js"><link rel="prefetch" href="/mynotes/assets/js/14.23c58989.js"><link rel="prefetch" href="/mynotes/assets/js/15.7f2952d0.js"><link rel="prefetch" href="/mynotes/assets/js/16.c6c9a35b.js"><link rel="prefetch" href="/mynotes/assets/js/17.026a9b21.js"><link rel="prefetch" href="/mynotes/assets/js/18.33a22882.js"><link rel="prefetch" href="/mynotes/assets/js/19.5bae9800.js"><link rel="prefetch" href="/mynotes/assets/js/3.10239fd0.js"><link rel="prefetch" href="/mynotes/assets/js/5.dba54d81.js"><link rel="prefetch" href="/mynotes/assets/js/6.f54abc5a.js"><link rel="prefetch" href="/mynotes/assets/js/7.c1be93cc.js"><link rel="prefetch" href="/mynotes/assets/js/8.7beb05ff.js"><link rel="prefetch" href="/mynotes/assets/js/9.ece7952f.js">
    <link rel="stylesheet" href="/mynotes/assets/css/0.styles.1c00a5d2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/mynotes/" class="home-link router-link-active"><!----> <span class="site-name">elbowH的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/mynotes/" class="nav-link">
  主页
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/mynotes/" class="nav-link">
  主页
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>JVM</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/mynotes/java/JVM/JVM实战-内存模型.html" class="sidebar-link">JVM实战-内存模型</a></li><li><a href="/mynotes/java/JVM/JVM实战-垃圾收集器.html" class="active sidebar-link">JVM实战-垃圾收集器</a></li><li><a href="/mynotes/java/JVM/JVM实战-垃圾收集算法.html" class="sidebar-link">JVM实战-垃圾收集算法</a></li><li><a href="/mynotes/java/JVM/JVM实战-对象实例化.html" class="sidebar-link">JVM实战-对象实例化</a></li></ul></section></li><li><a href="/mynotes/java/Java基础知识.html" class="sidebar-link">Java基础知识</a></li><li><a href="/mynotes/java/J2EE基础知识.html" class="sidebar-link">J2EE基础知识</a></li><li><a href="/mynotes/java/Java-Calendar.html" class="sidebar-link">Java-Calendar</a></li><li><a href="/mynotes/java/JDK7新特性概览.html" class="sidebar-link">JDK7新特性概览</a></li><li><a href="/mynotes/java/Java-Fork-Join-框架.html" class="sidebar-link">Java-Fork-Join-框架</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p></p><div class="table-of-contents"><ul><li><a href="#_1-1-serial垃圾收集器">1.1  Serial垃圾收集器</a></li><li><a href="#_1-2-parnew垃圾收集器">1.2 ParNew垃圾收集器</a></li><li><a href="#_2-1-多线程并行执行">2.1 多线程并行执行</a></li><li><a href="#_2-2-适合多cpu的服务器环境">2.2 适合多CPU的服务器环境</a></li><li><a href="#_2-3-采用-复制-算法">2.3 采用&quot;复制&quot;算法</a></li><li><a href="#_2-4-追求-降低停顿时间">2.4 追求&quot;降低停顿时间&quot;</a></li><li><a href="#_3-1-scavenge垃圾收集器">3.1 Scavenge垃圾收集器</a></li><li><a href="#_3-2-old垃圾收集器">3.2 Old垃圾收集器</a></li><li><a href="#_4-1-cms的缺点">4.1 CMS的缺点</a></li><li><a href="#_5-1-g1的特点">5.1 G1的特点</a></li><li><a href="#_5-2-g1的内存模型">5.2 G1的内存模型</a></li><li><a href="#_5-3-remembered-set">5.3 Remembered Set</a></li><li><a href="#_5-4-g1垃圾收集过程">5.4 G1垃圾收集过程</a></li></ul></div>
使用分代垃圾收集器,基于以下观察事实(弱分代假设)<p></p> <ul><li>大多数分配对象的存活时间短</li> <li>存活时间久的对象很少引用存活时间短的对象</li></ul> <p>由此, HotSpot VM 将堆分为两个物理区空间,这就是分代(永久代只存储元数据, eg. 类的数据结构,保留字符串( Interned String))</p> <p>根据新生代和老年代各自的特点,我们应该分别为它们选择不同的收集器,以提升垃圾回收效率.</p> <p><img src="/mynotes/assets/img/12402.3c8776e9.jpg" alt=""></p> <h1 id="_1-新生代垃圾收集器"><a href="#_1-新生代垃圾收集器" class="header-anchor">#</a> 1 新生代垃圾收集器</h1> <h2 id="_1-1-serial垃圾收集器"><a href="#_1-1-serial垃圾收集器" class="header-anchor">#</a> 1.1  Serial垃圾收集器</h2> <p>一个主要应用于Y-GC的垃圾回收器，采用串行单线程的方式完成GC任务，其中“Stop The World&quot;简称STW,即垃圾回收的某个阶段会暂停整个应用程序的执行
F-GC的时间相对较长，频繁FGC会严重影响应用程序的性能
<img src="/mynotes/assets/img/12403.f0fdb71a.jpg" alt="Serial 回收流程"> <code>单线程 Stop-The-World 式</code> <img src="/mynotes/assets/img/1240-16841485956572.844ebf04.jpg" alt=""></p> <ul><li>单线程
只会使用一个CPU或一条GC线程进行GC,并且在GC过程中暂停其他所有的工作线程,因此用户的请求或图形化界面会出现卡顿</li> <li>适合Client模式
一般客户端应用所需内存较小,不会创建太多的对象,而且堆内存不大,因此GC时间比较短,即使在这段时间停止一切用户线程,也不会感到明显停顿</li> <li>简单高效
由于Serial收集器只有一条GC线程,避免了线程切换的开销</li> <li>采用&quot;复制&quot;算法</li></ul> <h2 id="_1-2-parnew垃圾收集器"><a href="#_1-2-parnew垃圾收集器" class="header-anchor">#</a> 1.2 ParNew垃圾收集器</h2> <p>ParNew是Serial的多线程版本.
<img src="/mynotes/assets/img/1240-16841486034834.9be731f5.jpg" alt=""></p> <h2 id="_2-1-多线程并行执行"><a href="#_2-1-多线程并行执行" class="header-anchor">#</a> 2.1 多线程并行执行</h2> <p>ParNew由多条GC线程并行地进行垃圾清理.
但清理过程仍然需要暂停一切其他用户线程.
但由于有多条GC线程同时清理,清理速度比Serial有一定的提升</p> <h2 id="_2-2-适合多cpu的服务器环境"><a href="#_2-2-适合多cpu的服务器环境" class="header-anchor">#</a> 2.2 适合多CPU的服务器环境</h2> <p>由于使用多线程,是许多运行在 server 模式下的虚拟机首选的新生代收集器</p> <ul><li>与Serial性能对比
ParNew和Serial唯一区别就是使用了多线程垃圾回收,在多CPU的环境下性能比Serial会有一定程度的提升
但线程切换需要额外的开销,因此在单CPU环境中表现不如Serial,双CPU环境也不一定就比Serial高效
默认开启的收集线程数与CPU数量相同</li></ul> <h2 id="_2-3-采用-复制-算法"><a href="#_2-3-采用-复制-算法" class="header-anchor">#</a> 2.3 采用&quot;复制&quot;算法</h2> <h2 id="_2-4-追求-降低停顿时间"><a href="#_2-4-追求-降低停顿时间" class="header-anchor">#</a> 2.4 追求&quot;降低停顿时间&quot;</h2> <p>和Serial相比,ParNew使用多线程的目的就是缩短GC时间,从而减少用户线程被停顿的时间</p> <h1 id="_3-parallel-吞吐量为先"><a href="#_3-parallel-吞吐量为先" class="header-anchor">#</a> 3 Parallel : 吞吐量为先!</h1> <h2 id="_3-1-scavenge垃圾收集器"><a href="#_3-1-scavenge垃圾收集器" class="header-anchor">#</a> 3.1 Scavenge垃圾收集器</h2> <p>Parallel Scavenge和ParNew一样都是并行的多线程、新生代收集器,都使用&quot;复制&quot;算法(<code>Stop-The-World</code>)进行垃圾回收</p> <p>但它们有个巨大不同点:</p> <ul><li>ParNew收集器追求降低GC时用户线程的停顿时间,适合交互式应用,良好的反应速度提升用户体验.</li> <li>Parallel Scavenge追求可控的CPU吞吐量,能够在较短的时间内完成指定任务,适合不需太多交互的后台运算</li></ul> <blockquote><p>吞吐量是指用户线程运行时间占CPU总时间的比例.
CPU总时间包括 : 用户线程运行时间 和 GC线程运行的时间.
因此,吞吐量越高表示用户线程运行时间越长,从而用户线程能够被快速处理完.</p></blockquote> <ul><li><p>降低停顿时间的两种方式
1.在多CPU环境中使用多条GC线程,从而垃圾回收的时间减少,从而用户线程停顿的时间也减少;
2.实现GC线程与用户线程并发执行。所谓并发，就是用户线程与GC线程交替执行，从而每次停顿的时间会减少，用户感受到的停顿感降低，但线程之间不断切换意味着需要额外的开销，从而垃圾回收和用户线程的总时间将会延长。</p></li> <li><p>Parallel Scavenge提供的参数</p></li> <li><p>-XX:GCTimeRadio
直接设置吞吐量大小,GC时间占总时间比率.相当于是吞吐量的倒数.</p></li> <li><p>-XX:MaxGCPauseMillis
设置最大GC停顿时间
Parallel Scavenge会根据这个值的大小确定新生代的大小.
这个值越小,新生代就越小,从而收集器就能以较短时间进行一次GC
但新生代变小后,回收的频率就会提高,吞吐量也降下来了,因此要合理控制这个值</p></li> <li><p>-XX:+UseAdaptiveSizePolicy
开启GC <strong>自适应的调节策略(区别于ParNew)</strong>.
我们只要设置最大堆(-Xmx)和MaxGCPauseMillis或GCTimeRadio,收集器会自动调整新生代的大小、Eden和Survior的比例、对象进入老年代的年龄,以最大程度上接近我们设置的MaxGCPauseMillis或GCTimeRadio</p></li></ul> <h2 id="_3-2-old垃圾收集器"><a href="#_3-2-old垃圾收集器" class="header-anchor">#</a> 3.2 Old垃圾收集器</h2> <p>Parallel Scavenge的老年代版本,一般它们搭配使用,追求CPU吞吐量</p> <p>它们在垃圾收集时都是由多条GC线程并行执行,并暂停一切用户线程,使用&quot;标记-整理&quot;算法.因此,由于在GC过程中没有使垃圾收集和用户线程并行执行,因此它们是追求吞吐量的垃圾收集器.
<img src="/mynotes/assets/img/1240-16841486091606.98aa410c.jpg" alt=""></p> <h1 id="老年代垃圾收集器"><a href="#老年代垃圾收集器" class="header-anchor">#</a> <strong>老年代垃圾收集器</strong></h1> <h1 id="_1-serial-old垃圾收集器"><a href="#_1-serial-old垃圾收集器" class="header-anchor">#</a> 1 Serial Old垃圾收集器</h1> <p>Serial的老年代版本,都是单线程收集器,GC时只启动一条GC线程,因此都适合客户端应用.</p> <p>它们唯一的区别就是</p> <ul><li>Serial Old工作在老年代,使用&quot;标记-整理&quot;算法</li> <li>Serial工作在新生代,使用&quot;复制&quot;算法.
<img src="/mynotes/assets/img/1240-16841486107348.844ebf04.jpg" alt=""></li></ul> <h1 id="_4-cms垃圾收集器-concurrent-mark-sweep-collector-低延迟为先"><a href="#_4-cms垃圾收集器-concurrent-mark-sweep-collector-低延迟为先" class="header-anchor">#</a> 4  CMS垃圾收集器(Concurrent Mark Sweep Collector) : 低延迟为先!</h1> <p>回收停顿时间比较短、目前比较常用的垃圾回收器。它通过初始标记(InitialMark)、并发标记(Concurrent   Mark)、重新标记( Remark)、并发清除( Concurrent Sweep )四个步骤完成垃圾回收工作
由于CMS采用的是“标记-清除算法&quot;，因此戸生大量的空间碎片。为了解决这个问题，CMS可以通过配置</p> <div class="language- extra-class"><pre class="language-text"><code>-XX:+UseCMSCompactAtFullCollection
</code></pre></div><p>参数，强制JVM在FGC完成后対老年代迸行圧縮，执行一次空间碎片整理，但是空间碎片整理阶段也会引发STW。为了减少STW次数，CMS还可以通过配置</p> <div class="language- extra-class"><pre class="language-text"><code>-XX:+CMSFullGCsBeforeCompaction=n
</code></pre></div><p>参数，在执行了n次FGC后, JVM再在老年代执行空间碎片整理</p> <p>对许多应用来说,快速响应比端到端的吞吐量更为重要</p> <p>管理新生代的方法与 parallel 和 serial 相同
在老年代则尽可能并发执行,每个 GC 周期只有2次短的停顿</p> <p>一种追求最短停顿时间的收集器
在GC时使得用户线程和GC线程并发执行,因此在GC过程中用户也不会感受到明显卡顿
但用户线程和GC线程之间不停地切换会有额外的开销,因此垃圾回收总时间就会被延长
<strong>垃圾回收过程</strong>
前两步需要&quot;Stop The World&quot;</p> <ul><li>初始标记 (Initial Mark)
停止一切用户线程,仅使用一条初始标记线程对所有与GC Roots直接相关联的 老年代对象进行标记,速度很快</li> <li>并发标记 (Concurrent Marking Phase)
使用多条并发标记线程并行执行,并与用户线程并发执行.此过程进行可达性分析,标记所有这些对象可达的存货对象,速度很慢</li> <li>重新标记 ( Remark)
因为并发标记时有用户线程在执行，标记结果可能有变化
停止一切用户线程,并使用多条重新标记线程并行执行,重新遍历所有在并发标记期间有变化的对象进行最后的标记.这个过程的运行时间介于初始标记和并发标记之间</li> <li>并发清除 (Concurrent Sweeping)
只使用一条并发清除线程,和用户线程们并发执行,清除刚才标记的对象
这个过程非常耗时
<img src="/mynotes/assets/img/1240-168414861312210.aac4139c.jpg" alt=""></li></ul> <h2 id="_4-1-cms的缺点"><a href="#_4-1-cms的缺点" class="header-anchor">#</a> 4.1 <strong>CMS的缺点</strong></h2> <ul><li>吞吐量低
由于CMS在GC过程用户线程和GC线程并行,从而有线程切换的额外开销
因此CPU吞吐量就不如在GC过程中停止一切用户线程的方式来的高</li> <li>无法处理浮动垃圾,导致频繁Full GC
由于垃圾清除过程中,用户线程和GC线程并发执行,也就是用户线程仍在执行,那么在执行过程中会产生垃圾,这些垃圾称为&quot;浮动垃圾&quot;
如果CMS在GC过程中,用户线程需要在老年代中分配内存时发现空间不足,就需再次发起Full GC,而此时CMS正在进行清除工作,因此此时只能由Serial Old临时对老年代进行一次Full GC</li> <li>使用&quot;标记-清除&quot;算法产生碎片空间
由于CMS使用了&quot;标记-清除&quot;算法, 因此清除之后会产生大量的碎片空间,不利于空间利用率.不过CMS提供了应对策略:
<ul><li>开启-XX:+UseCMSCompactAtFullCollection
开启该参数后,每次FullGC完成后都会进行一次内存压缩整理,将零散在各处的对象整理到一块儿.但每次都整理效率不高,因此提供了以下参数.</li> <li>设置参数-XX:CMSFullGCsBeforeCompaction
本参数告诉CMS,经过了N次Full GC过后再进行一次内存整理.</li></ul></li></ul> <h1 id="_5-g1收集器-garbage-first"><a href="#_5-g1收集器-garbage-first" class="header-anchor">#</a> 5 G1收集器(Garbage-First)</h1> <p>Hotspot 在JDK7中推出了新一代 G1 ( Garbage-First Garbage Collector )垃圾回收，通过</p> <div class="language- extra-class"><pre class="language-text"><code>-XX:+UseG1GC
</code></pre></div><p>参数启用
和CMS相比，Gl具备压缩功能，能避免碎片向題，G1的暂停时间更加可控。性能总体还是非常不错的,G1是当今最前沿的垃圾收集器成果之一.</p> <h2 id="_5-1-g1的特点"><a href="#_5-1-g1的特点" class="header-anchor">#</a> 5.1 G1的特点</h2> <ul><li>追求停顿时间</li> <li>多线程GC</li> <li>面向服务端应用</li> <li>整体来看基于标记-整理和局部来看基于复制算法合并
不会产生内存空间碎片</li> <li>可对整个堆进行垃圾回收</li> <li>可预测的停顿时间</li></ul> <h2 id="_5-2-g1的内存模型"><a href="#_5-2-g1的内存模型" class="header-anchor">#</a> 5.2 G1的内存模型</h2> <p>没有新生代和老年代的概念,而是将Java堆划分为一块块独立的大小相等的Region.
当要进行垃圾收集时,首先估计每个Region中的垃圾数量,每次都从垃圾回收价值最大的Region开始回收,因此可以获得最大的回收效率
<img src="/mynotes/assets/img/1240-168414861845612.6d187bc9.jpg" alt="">
G1将Java堆空间分割成了若干相同大小的区域，即region
包括</p> <ul><li>Eden</li> <li>Survivor</li> <li>Old</li> <li>Humongous</li></ul> <p>其中，<code>Humongous</code>是特殊的Old类型,专门放置大型对象.
这样的划分方式意味着不需要一个连续的内存空间管理对象.G1将空间分为多个区域,<strong>优先回收垃圾最多</strong>的区域.
G1采用的是<strong>Mark-Copy</strong> ，有非常好的空间整合能力,不会产生大量的空间碎片
G1的一大优势在于可预测的停顿时间,能够尽可能快地在指定时间内完成垃圾回收任务
在JDK11中，已经将G1设为默认垃圾回收器，通过jstat命令可以查看垃圾回收情况,在YGC时S0/S1并不会交换.</p> <h2 id="_5-3-remembered-set"><a href="#_5-3-remembered-set" class="header-anchor">#</a> 5.3 Remembered Set</h2> <p>一个对象和它内部所引用的对象可能不在同一个Region中,那么当垃圾回收时,是否需要扫描整个堆内存才能完整地进行一次可达性分析?
当然不是,每个Region都有一个Remembered Set,用于记录本区域中所有对象引用的对象所在的区域,从而在进行可达性分析时,只要在GC Roots中再加上Remembered Set即可防止对所有堆内存的遍历.</p> <h2 id="_5-4-g1垃圾收集过程"><a href="#_5-4-g1垃圾收集过程" class="header-anchor">#</a> 5.4 G1垃圾收集过程</h2> <ul><li>初始标记
标记与GC Roots直接关联的对象,停止所有用户线程,只启动一条初始标记线程,这个过程很快.</li> <li>并发标记
进行全面的可达性分析,开启一条并发标记线程与用户线程并行执行.这个过程比较长.</li> <li>最终标记
标记出并发标记过程中用户线程新产生的垃圾.停止所有用户线程,并使用多条最终标记线程并行执行.</li> <li>筛选回收
回收废弃的对象.此时也需要停止一切用户线程,并使用多条筛选回收线程并行执行.
<img src="/mynotes/assets/img/1240-168414862036914.5891cd04.jpg" alt="这里写图片描述"></li></ul> <p>S0/S1的功能由G1中的Survivor region来承载,通过GC日志可以观察到完整的垃圾回收过程如下，其中就有Survivor regions的区域从0个到1个
<img src="/mynotes/assets/img/1240-168414862204916.e6398e5e.jpg" alt="">
红色标识的为G1中的四种region,都处于Heap中.
G1执行时使用4个worker并发执行，在初始标记时，还是会触发STW,如第一步所示的Pause</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/mynotes/java/JVM/JVM实战-内存模型.html" class="prev">
        JVM实战-内存模型
      </a></span> <span class="next"><a href="/mynotes/java/JVM/JVM实战-垃圾收集算法.html">
        JVM实战-垃圾收集算法
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/mynotes/assets/js/app.f65f9fb1.js" defer></script><script src="/mynotes/assets/js/2.7a2c11e9.js" defer></script><script src="/mynotes/assets/js/4.6de9dd4b.js" defer></script>
  </body>
</html>
